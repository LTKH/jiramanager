

import (
	"net/http"
	"log"
)

func newRequest(cfg config.Config, method string, url string, jsonStr []byte, login string, password string) ([]byte, error) {
	log.Printf("[debug] -- new request (%v)", url)

	//ignore certificate
	http.DefaultTransport.(*http.Transport).TLSClientConfig = &tls.Config{InsecureSkipVerify: true}

	req, err := http.NewRequest(method, url, bytes.NewBuffer(jsonStr))
	if err != nil {
		return nil, err
	}
	req.SetBasicAuth(login, password)
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var dat interface{}
	if err := json.Unmarshal(body, &dat); err != nil {
		return nil, err
	}

	return body, nil

}

func newTemplate(cfg config.Config, name string, vals interface{}) []byte {
	log.Printf("[debug] -- create new template (%v)", name)

	funcMap := template.FuncMap{
		"int": func(s string) (int, error){
		c, err := strconv.Atoi(s)
		if err != nil {
			return 0, err
		}
		return c, nil
		},
	}

	tmpl, err := template.New(name+".tmpl").Funcs(funcMap).ParseFiles(cfg.Jiramanager.Tmpl_dir+"/"+name+".tmpl")
	if err != nil {
		log.Printf("[error] %v", err)
		return []byte("")
	}

	var tpl bytes.Buffer
	if err = tmpl.Execute(&tpl, &vals); err != nil {
		log.Printf("[error] %v", err)
		return []byte("")
	}

	re := regexp.MustCompile(`\{[\s\S]*\}`)
	if re.MatchString(tpl.String()) == false {
		return []byte("")
	}

	return tpl.Bytes()
	}

	func parseJson(jsn []byte) (map[string]interface{}, error) {
	var dat map[string]interface{}
	if err := json.Unmarshal(jsn, &dat); err != nil {
		log.Printf("[error] %v", err)
		return nil, err
	}
	return dat, nil
}

func searchTask(cfg config.Config, tmpl string, alrt map[string]interface{}) bool {
	log.Printf("[debug] -- serching old task (%v)", tmpl)

	alrt["task_key"] = db.GetTaskKey(cfg, alrt["mgrp_id"].(string))
	if alrt["task_key"] == "" {
		log.Print("[debug] task_key is empty")
		return false
	}

	def := newTemplate(cfg, tmpl, alrt)
	log.Printf("[debug] %v", string(def))

	sch, err := newRequest(cfg, "POST", cfg.Jiramanager.Jira_api+"/search", def, cfg.Jiramanager.Login, cfg.Jiramanager.Passwd)
	if err != nil {
		log.Printf("[debug] %v", err)
		return true
	}
	log.Printf("[debug] %v", string(sch))

	js, err := parseJson(sch)
	if err != nil {
		log.Printf("[error] %v", err)
		return true
	}

	if js["issues"] != nil {
		arr := js["issues"].([]interface{})
		if len(arr) > 0 {
		return true
		}
	}

	return false
}

func createTask(cfg config.Config, tmpl string, alrt map[string]interface{}) bool {

	def := newTemplate(cfg, tmpl, alrt)
	if string(def) == "" {
		log.Printf("[debug] default template is empty (%v)", alrt["mgrp_id"].(string))
		return false
	}
	log.Printf("[debug] %v", string(def))

	if cfg.Jiramanager.Search {
		if searchTask(cfg, "search", alrt) {
		log.Printf("[info] task already exists (%v)", alrt["mgrp_id"].(string))
		return false
		}
	}

	_, err := parseJson(def)
	if err != nil {
		log.Printf("[error] %v", err)
		return false
	}

	crt, err := newRequest(cfg, "POST", cfg.Jiramanager.Jira_api+"/issue", def, cfg.Jiramanager.Login, cfg.Jiramanager.Passwd)
	if err != nil {
		log.Printf("[error] %v", err)
		return false
	}
	log.Printf("[debug] %v", string(crt))

	js, err := parseJson(crt)
	if err != nil {
		log.Printf("[error] %v", crt)
		return false
	}
	if js["errorMessages"] != nil {
		log.Printf("[error] %v", string(crt))
		return false
	}

	if js["key"] != nil {
		db.UpdateTask(cfg, alrt["mgrp_id"].(string), js["key"].(string))
	}

	return true
}

func getTemplateResources(config Config) ([]*TemplateResource, error) {
	var lastError error
	templates := make([]*TemplateResource, 0)
	log.Debug("Loading template resources from confdir " + config.ConfDir)
	if !util.IsFileExist(config.ConfDir) {
		log.Warning(fmt.Sprintf("Cannot load template resources: confdir '%s' does not exist", config.ConfDir))
		return nil, nil
	}
	paths, err := util.RecursiveFilesLookup(config.ConfigDir, "*toml")
	if err != nil {
		return nil, err
	}

	if len(paths) < 1 {
		log.Warning("Found no templates")
	}

	for _, p := range paths {
		log.Debug(fmt.Sprintf("Found template: %s", p))
		t, err := NewTemplateResource(p, config)
		if err != nil {
			lastError = err
			continue
		}
		templates = append(templates, t)
	}
	return templates, lastError
}